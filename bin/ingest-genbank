#!/bin/bash
# usage: ingest-genbank [--fetch] [--nextclade_full_run]
#        ingest-genbank --help
#
# Ingest SARS-CoV-2 metadata and sequences from GenBank.
#
# If the --fetch flag is given, new records are fetched from GenBank. Otherwise,
# ingest from the existing GenBank NDJSON file on S3.
#
# If the --nextclade_full_run flag is given, the existing clade data is ignored
# and a full Nextclade run is performed, recomputing clades and other metrics
# for all sequences. This is necessary every time when new clades are defined or
# when upgrading to the new version of Nextclade with breaking changes.
# Note: this might take very long time to run, depending on available
# computational resources.
#
set -euo pipefail

: "${S3_SRC:=s3://nextstrain-data/files/ncov/open}"
: "${S3_DST:=$S3_SRC}"

main() {
    local fetch=0
    local nextclade_full_run=0

    for arg; do
        case "$arg" in
            -h|--help)
                print-help
                exit
                ;;
            --fetch)
                fetch=1
                shift
                break
                ;;
            --nextclade_full_run)
                nextclade_full_run=1
                shift
                break
                ;;
        esac
    done

    # Determine where to save data files based on if we're running as a result of a
    # push to master or to another branch (or locally, outside of the GitHub
    # workflow).  Files are always compared to the default/primary paths in the
    # source S3 bucket.
    #
    silent=
    branch=

    case "${GITHUB_REF:-}" in
        refs/heads/master)
            # Do nothing different; defaults above are good.
            branch=master
            ;;
        refs/heads/*)
            # Save data files under a per-branch prefix
            silent=yes
            branch="${GITHUB_REF##refs/heads/}"
            S3_DST="${S3_DST/nextstrain-data/nextstrain-staging}/branch/$branch"
            ;;
        "")
            # Save data files under a tmp prefix
            silent=yes
            S3_DST="${S3_DST/nextstrain-data/nextstrain-staging}/tmp"
            ;;
        *)
            echo "Skipping ingest for ref $GITHUB_REF"
            exit 0
            ;;
    esac

    # In 'full run' mode we pretend that we run from a git branch
    # and we write results to a special directory on S3, to keep
    # production (master) files intact.
    if [ "$nextclade_full_run" == 1 ]; then
      branch="nextclade_full_run"
      S3_DST="$S3_DST/nextclade-full-run/$(date "+%Y-%m-%d--%H-%M-%S--%Z")"
    fi

    echo "S3_SRC is $S3_SRC"
    echo "S3_DST is $S3_DST"

    cd "$(dirname "$0")/.."

    set -x

    if [[ "$fetch" == 1 ]]; then
        local attempt=0 max_attempts=5

        while [[ $((++attempt)) -le $max_attempts ]]; do
            echo "Fetch GenBank attempt $attempt"
            if ./bin/fetch-from-genbank > data/genbank.ndjson; then
                break
            else
                echo "...FAILED"
                rm data/genbank.ndjson
                sleep 10
            fi
        done
        if [[ ! -f data/genbank.ndjson ]]; then
            echo "Failed to fetch from GenBank"
            exit 1
        fi

        attempt=0
        while [[ $((++attempt)) -le $max_attempts ]]; do
            echo "Fetch BioSample attempt $attempt"
            if ./bin/fetch-from-biosample > data/biosample.ndjson; then
                break
            else
                echo "...FAILED"
                rm data/biosample.ndjson
                sleep 10
            fi
        done
        if [[ ! -f data/biosample.ndjson ]]; then
            echo "Failed to fetch from BioSample"
            exit 1
        fi

        if [[ "$branch" == master ]]; then
            ./bin/notify-on-record-change data/genbank.ndjson "$S3_SRC/genbank.ndjson.xz" "GenBank"
        fi
        ./bin/upload-to-s3 ${silent:+--quiet} data/genbank.ndjson "$S3_DST/genbank.ndjson.xz"
        ./bin/upload-to-s3 ${silent:+--quiet} data/biosample.ndjson "$S3_DST/biosample.ndjson.xz"
    else
        aws s3 cp --no-progress "$S3_DST/genbank.ndjson.xz" - | xz -cdfq > data/genbank.ndjson
        aws s3 cp --no-progress "$S3_DST/biosample.ndjson.xz" - | xz -cdfq > data/biosample.ndjson
    fi

    ./bin/transform-biosample data/biosample.ndjson \
        --output data/genbank/biosample.tsv

    ./bin/transform-genbank data/genbank.ndjson \
        --biosample data/genbank/biosample.tsv \
        --duplicate-biosample data/genbank/duplicate_biosample.txt \
        --output-metadata data/genbank/metadata.tsv \
        --output-fasta data/genbank/sequences.fasta
    ./bin/check-locations data/genbank/metadata.tsv \
        data/genbank/location_hierarchy.tsv \
        genbank_accession

    # Nextclade will recompute all rows if nextclade_old.tsv is empty
    if [ "$nextclade_full_run" == 0 ]; then
      # Download old clades
      (   aws s3 cp --no-progress "$S3_DST/nextclade.tsv.gz" - \
          || aws s3 cp --no-progress "$S3_SRC/nextclade.tsv.gz" -) \
          | gunzip -cfq \
          > "data/genbank/nextclade_old.tsv"
    else
      touch "data/genbank/nextclade_old.tsv"
    fi

    # Find sequences in FASTA which don't have clades assigned yet
    ./bin/filter-fasta \
        --input_fasta="data/genbank/sequences.fasta" \
        --input_tsv="data/genbank/nextclade_old.tsv" \
        --output_fasta="data/genbank/nextclade.sequences.fasta" \

    # And if it's not empty, run nextclade analysis on these sequences,
    # to assign clades and calculate other useful metrics
    ./bin/run-nextclade \
      "data/genbank/nextclade.sequences.fasta" \
      "data/genbank/nextclade_new.tsv" \
      "data/genbank/nextclade-inputs" \
      "data/genbank/nextclade"

    # Join new and old clades, so that next run won't need to process sequences that are already processed
    ./bin/join-rows \
      "data/genbank/nextclade_old.tsv" \
      "data/genbank/nextclade_new.tsv" \
      -o "data/genbank/nextclade.tsv"

    # Join these clades into metadata
    ./bin/join-metadata-and-clades \
        "data/genbank/metadata.tsv" \
        "data/genbank/nextclade.tsv" \
        -o "data/genbank/metadata.tsv"


    if [[ "$branch" == master ]]; then
        ./bin/notify-on-metadata-change data/genbank/metadata.tsv "$S3_SRC/metadata.tsv.gz" genbank_accession
        ./bin/notify-on-problem-data data/genbank/problem_data.tsv
        ./bin/notify-on-location-hierarchy-addition data/genbank/location_hierarchy.tsv source-data/location_hierarchy.tsv
        ./bin/notify-on-duplicate-biosample-change data/genbank/duplicate_biosample.txt "$S3_SRC/duplicate_biosample.txt.gz"
    fi

    ./bin/upload-to-s3 ${silent:+--quiet} data/genbank/metadata.tsv "$S3_DST/metadata.tsv.gz"
    ./bin/upload-to-s3 ${silent:+--quiet} data/genbank/sequences.fasta "$S3_DST/sequences.fasta.xz"
    ./bin/upload-to-s3 ${silent:+--quiet} data/genbank/nextclade.tsv "$S3_DST/nextclade.tsv.gz"
    ./bin/upload-to-s3 ${silent:+--quiet} data/genbank/biosample.tsv "$S3_DST/biosample.tsv.gz"
    ./bin/upload-to-s3 ${silent:+--quiet} data/genbank/duplicate_biosample.txt "$S3_DST/duplicate_biosample.txt.gz"

    ./bin/clean
}

print-help() {
    # Print the help comments at the top of this file ($0)
    local line
    while read -r line; do
        if [[ $line =~ ^#! ]]; then
            continue
        elif [[ $line =~ ^# ]]; then
            line="${line/##/}"
            line="${line/# /}"
            echo "$line"
        else
            break
        fi
    done < "$0"
}

main "$@"
