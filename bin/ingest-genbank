#!/bin/bash
# usage: ingest-genbank [--fetch]
#        ingest-genbank --help
#
# Ingest SARS-CoV-2 metadata and sequences from GenBank.
#
# If the --fetch flag is given, new records are fetched from GenBank. Otherwise,
# ingest from the existing GenBank NDJSON file on S3.
#

set -euo pipefail

: "${S3_SRC:=s3://nextstrain-data/files/ncov/open}"
: "${S3_DST:=$S3_SRC}"

main() {
    local fetch=0

    for arg; do
        case "$arg" in
            -h|--help)
                print-help
                exit
                ;;
            --fetch)
                fetch=1
                shift
                break
                ;;
        esac
    done

    # Determine where to save data files based on if we're running as a result of a
    # push to master or to another branch (or locally, outside of the GitHub
    # workflow).  Files are always compared to the default/primary paths in the
    # source S3 bucket.
    #
    silent=
    branch=

    case "${GITHUB_REF:-}" in
        refs/heads/master)
            # Do nothing different; defaults above are good.
            branch=master
            ;;
        refs/heads/*)
            # Save data files under a per-branch prefix
            silent=yes
            branch="${GITHUB_REF##refs/heads/}"
            S3_DST="${S3_DST/nextstrain-data/nextstrain-staging}/branch/$branch"
            ;;
        "")
            # Save data files under a tmp prefix
            silent=yes
            S3_DST="${S3_DST/nextstrain-data/nextstrain-staging}/tmp"
            ;;
        *)
            echo "Skipping ingest for ref $GITHUB_REF"
            exit 0
            ;;
    esac

    echo "S3_SRC is $S3_SRC"
    echo "S3_DST is $S3_DST"

    cd "$(dirname "$0")/.."

    if [[ "$branch" == master ]]; then
      ./bin/notify-on-job-start "ðŸ¥£ GenBank ingest"
    fi

    if [[ "$fetch" == 1 ]]; then
        local attempt=0 max_attempts=5

        while [[ $((++attempt)) -le $max_attempts ]]; do
            echo "Fetch GenBank attempt $attempt"
            if ./bin/fetch-from-genbank > data/genbank.ndjson; then
                break
            else
                echo "...FAILED"
                rm data/genbank.ndjson
                sleep 10
            fi
        done
        if [[ ! -f data/genbank.ndjson ]]; then
            echo "Failed to fetch from GenBank"
            exit 1
        fi

        attempt=0
        while [[ $((++attempt)) -le $max_attempts ]]; do
            echo "Fetch BioSample attempt $attempt"
            if ./bin/fetch-from-biosample > data/biosample.ndjson; then
                break
            else
                echo "...FAILED"
                rm data/biosample.ndjson
                sleep 10
            fi
        done
        if [[ ! -f data/biosample.ndjson ]]; then
            echo "Failed to fetch from BioSample"
            exit 1
        fi

        if [[ "$branch" == master ]]; then
            ./bin/notify-on-record-change data/genbank.ndjson "$S3_SRC/genbank.ndjson.xz" "GenBank"
        fi
        ./bin/upload-to-s3 ${silent:+--quiet} data/genbank.ndjson "$S3_DST/genbank.ndjson.xz"
        ./bin/upload-to-s3 ${silent:+--quiet} data/biosample.ndjson "$S3_DST/biosample.ndjson.xz"
    else
        ./bin/download-from-s3 "$S3_DST/genbank.ndjson.xz" "data/genbank.ndjson"
        ./bin/download-from-s3 "$S3_DST/biosample.ndjson.xz" "data/biosample.ndjson"
    fi

    ./bin/transform-biosample data/biosample.ndjson \
        --output data/genbank/biosample.tsv

    ./bin/transform-genbank data/genbank.ndjson \
        --biosample data/genbank/biosample.tsv \
        --duplicate-biosample data/genbank/duplicate_biosample.txt \
        --output-metadata data/genbank/metadata.tsv \
        --output-fasta data/genbank/sequences.fasta
    ./bin/check-locations data/genbank/metadata.tsv \
        data/genbank/location_hierarchy.tsv \
        genbank_accession

    # Download old clades
    ./bin/download-from-s3 "$S3_DST/nextclade.tsv.gz" "data/genbank/nextclade_old.tsv" ||  \
    ./bin/download-from-s3 "$S3_SRC/nextclade.tsv.gz" "data/genbank/nextclade_old.tsv"

    # Find sequences in FASTA which don't have clades assigned yet
    ./bin/filter-fasta \
        --input_fasta="data/genbank/sequences.fasta" \
        --input_tsv="data/genbank/nextclade_old.tsv" \
        --output_fasta="data/genbank/nextclade.sequences.fasta" \

    # And if it's not empty, run nextclade analysis on these sequences,
    # to assign clades and calculate other useful metrics
    ./bin/run-nextclade \
      "data/genbank/nextclade.sequences.fasta" \
      "data/genbank/nextclade_new.tsv" \
      "data/genbank/nextclade-inputs" \
      "data/genbank/nextclade" \
      "data/genbank/nextclade.aligned.new.fasta"

    # Join new and old clades, so that next run won't need to process sequences that are already processed
    ./bin/join-rows \
      "data/genbank/nextclade_old.tsv" \
      "data/genbank/nextclade_new.tsv" \
      -o "data/genbank/nextclade.tsv"

    # Download old alignment
    ./bin/download-from-s3 "$S3_DST/nextclade.aligned.fasta.xz" "data/genbank/nextclade.aligned.old.fasta"

    # Join new and old alignment
    cat "data/genbank/nextclade.aligned.old.fasta" \
        "data/genbank/nextclade.aligned.new.fasta" \
       >"data/genbank/nextclade.aligned.fasta"

    # Join these clades into metadata
    ./bin/join-metadata-and-clades \
        "data/genbank/metadata.tsv" \
        "data/genbank/nextclade.tsv" \
        -o "data/genbank/metadata.tsv"

    # Download old peptides and join with the new ones
    # Note: gene filenames are in the form: "nextclade.gene.S.fasta"
    for gene_fasta_path in data/genbank/nextclade/*.gene.*.fasta; do
      gene_fasta_filename="$(basename "${gene_fasta_path}")"

      ./bin/download-from-s3 "$S3_DST/${gene_fasta_filename}.xz" "data/genbank/old.${gene_fasta_path}.fasta"

      cat "data/genbank/old.${gene_fasta_path}.fasta" \
          "data/genbank/nextclade/${gene_fasta_path}" \
         >"data/genbank/${gene_fasta_path}"
    done

    if [[ "$branch" == master ]]; then
        ./bin/notify-on-metadata-change data/genbank/metadata.tsv "$S3_SRC/metadata.tsv.gz" genbank_accession
        ./bin/notify-on-problem-data data/genbank/problem_data.tsv
        ./bin/notify-on-location-hierarchy-addition data/genbank/location_hierarchy.tsv source-data/location_hierarchy.tsv
        ./bin/notify-on-duplicate-biosample-change data/genbank/duplicate_biosample.txt "$S3_SRC/duplicate_biosample.txt.gz"
    fi

    ./bin/upload-to-s3 ${silent:+--quiet} data/genbank/metadata.tsv "$S3_DST/metadata.tsv.gz"
    ./bin/upload-to-s3 ${silent:+--quiet} data/genbank/sequences.fasta "$S3_DST/sequences.fasta.xz"
    ./bin/upload-to-s3 ${silent:+--quiet} data/genbank/nextclade.tsv "$S3_DST/nextclade.tsv.gz"
    ./bin/upload-to-s3 ${silent:+--quiet} data/genbank/biosample.tsv "$S3_DST/biosample.tsv.gz"
    ./bin/upload-to-s3 ${silent:+--quiet} data/genbank/duplicate_biosample.txt "$S3_DST/duplicate_biosample.txt.gz"

    if [ -f "data/genbank/nextclade.aligned.fasta" ]; then
      ./bin/upload-to-s3 ${silent:+--quiet} data/genbank/nextclade.aligned.fasta "$S3_DST/nextclade.aligned.fasta.xz"
    fi

    # Upload each gene fasta
    for gene_fasta_path in data/genbank/*.gene.*.fasta; do
      if [ -f "${gene_fasta_path}" ]; then
        gene_fasta_filename="$(basename "${gene_fasta_path}")"
        ./bin/upload-to-s3 ${silent:+--quiet} "${gene_fasta_path}" "$S3_DST/${gene_fasta_filename}.xz"
      fi
    done

    ./bin/clean

    if [[ "$fetch" == 1 && "$branch" == master ]]; then
        echo "Triggering ncov preprocessing GitHub action via repository dispatch."
        curl -fsS https://api.github.com/repos/nextstrain/ncov/dispatches \
          -H 'Accept: application/vnd.github.v3+json' \
          -H 'Content-Type: application/json' \
          -H "authorization: Bearer ${PAT_GITHUB_DISPATCH}" \
          -d '{"event_type":"preprocess-open"}'
    else
        echo "Skipping running of ncov preprocessing workflow as the current branch is not master or we are running an ingest only (not a fetch-and-ingest)."
    fi
}

print-help() {
    # Print the help comments at the top of this file ($0)
    local line
    while read -r line; do
        if [[ $line =~ ^#! ]]; then
            continue
        elif [[ $line =~ ^# ]]; then
            line="${line/##/}"
            line="${line/# /}"
            echo "$line"
        else
            break
        fi
    done < "$0"
}

main "$@"
